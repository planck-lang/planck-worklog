# 20190822

## 배열 자료형의 내부 구현

먼저 구현하는 기능이 배열이어서 일단 배열을 대상으로 구현한다. 하지만 공통적 특성상 배열에 대해 구현하는 기능의 상당 부분은 이터레이션이 가능한 많은 자료형에서 공통적으로 사용할 수 있을 것으로 생각한다.

배열 기능 구현 순서는 일반적인 변수 기능을 구현 할 때처럼 선언, 참조, 변경이다. 다만 배열로 기능을 확장했기 때문에 고려해야할 기능 요소가 더 많다. 그래서 구현이 더 복잡하다.

선언 기능을 만들기 전에, 가상 머신 스택에서 배열의 데이터를 어떻게 처리할지 결정해야 한다. 배열 데이터란 별것 아니다. 그냥 단일 데이터를 묶어서 다루는 것이다. 지금까지 구현에서 플랑크는 가상 머신 스택을 연산 할 때 사용하는 임시 데이터 영역으로만 쓰고 데이터 자체는 변수를 통해 심볼 테이블에 저장했다. 배열에 대해서도 마찬가지 규칙을 적용했다. 

배열 변수에 배열 데이터를 초기값으로 선언해 넣기 전에 배열 데이터 자체에 대해서 구현한다. 즉, 배열의 초기값 설정 자체도 독립된 표현식(expression)이다. 먼저 단일 표현식이 스택에서 어떻게 동작하는지 다시 생각해 본다. 값이 하나 스택에 쌓이고(push) 연산이 필요하면 스택에서 값을 빼서(pop) 연산한 다음 다시 스택에 넣는다. 그래서 어떤 표현식이건 가상 머신이 표현식을 다 처리하고 나면 스택에는 값이 하나만 남아 있다. 이 남은 값을 화면으로 출력하거나 심볼 테이블에 넣는 것이다. 배열도 마찬가지로 동작하게 만들면 된다.

```
[1,2,3]
```

가장 단순한 배열 데이터다. 배열의 각 아이템은 개별적 표현식이므로 아래 코드도 유효하다.

```
[1, 1+1, 3]
```

어떤 코드건 문법적으로 문제가 없다면 가상 머신이 처리를 하고 난 후에 스택 상태는 같은 형태다. 위 두 코드는 스택에 순서대로 1, 2, 3이 쌓여 있다. 스택이므로 값을 뺄 때는 3, 2, 1 순서로 값이 나온다. 이 점을 염두하고 배열 객체를 만든다.

가상 머신이 표현식 처리를 끝내고 나면 스택에는 표현식에 대한 결과 하나만 있어야 한다. 그러나 현재 배열 데이터 처리를 구현하는 중간에서 보면 스택에는 값이 세 개가 있다. 가상 머신에 연산을 하나 더 구현해서 스택에 있는 값들을 묶어야 한다. 값을 묶은 것이 배열이니 배열의 정의에 매우 부합하는 동작이다. 그래서 ARRAY라는 opcode를 추가한다. 그러면 위 첫 번째 코드는 아래와 같은 바이트 코드로 번역된다.

```
PUSH 1
PUSH 2
PUSH 3
ARRAY 3
```

ARRAY opcode의 아규먼트로 3을 썼다. 3은 배열의 아이템 개수를 의미한다. 배열의 크기라고 생각하면 된다. ARRAY 3이라는 명령을 읽으면 가상 머신은 스택에서 값을 3개 꺼낸다. 그리고 그 꺼낸 값 세개를 객체 한 개로 묶은 다음 다시 스택에 넣는다. 그러면 마지막에는 스택에 배열 객체 하나만 존재한다.

유의할 점은 지금까지 구현 편의를 위해서 커다란 플랑크 데이터 객체를 값으로 복사해서 (copy of value) 기능을 구현했다. 그러나 배열은 플랑크 데이터 객체를 동적 할당으로 만들어 넣었으므로 메모리 누수가 발생하지 않도록 구현할 때 세심히 봐야한다.
