# 20190725

## if 문 코드 점프

if 문은 단순한 동작이다. if 문에 조건식이 True면 따라오는 코드 블럭을 실행하고 False면 코드 블록을 건너 뛴다. 

```
if a == 3 {
	a = 4;
}
:
```

위 플랑크 코드를 플랑크 바이트 코드로 바꾸면,

```
LOAD a
PUSH 3
EQ
CMP 3
PUSH 4
STORE a
:
```

이다. EQ opcode는 스택에서 값 두 개를 뽑아서 같은지 비교하고 결과를 boolean 타입으로 스택에 다시 넣는다. CMP opcode는 스택에서 값을 뽑아 true면 다음 명령을 실행(pc + 1)하고 false면 파라메터 만큼 jump한다. 위 코드에서는 파라메터가 3이므로 (pc + 3) 위치로 점프해서 실행한다. 그리고 스택의 값이 boolean이 아니면 런타임 에러를 낸다.

간단하다. 그러나 이 기능을 구현하면서 몇 가지 삽질했다. CMP opcode의 파라메터를 결정하는 부분이다. 바이트코드 바이너리 파일 입력을 고려하지 않는다면 가장 직관적이고 쉬운 구현은 인터프리터 내부 바이트코드 버퍼의 메모리 주소를 파라메터로 바로 쓰는 것이다. 그러나 바이트코드 바이너리 파일 입력을 고려하면 CMP opcode의 파라메터는 어떤 형태든 상대 주소(Relative addressing)여야 한다.

직관적으로 이해하기 쉬운 상대 주소는 기준점에서 얼마나 떨어져 있는지를 표시하는 것이다. 흔히 오프셋(offset)이라고 부르는 값이다. 오프셋을 두 가지 방법으로 정할 수 있다. 하나는 시작 위치 기준 오프셋이고 다른 하나는 현재 위치 기준 오프셋이다. 결론적으로 나는 현재 위치 기준 오프셋을 사용했다. 그래서 위 플랑크 바이트코드 예제에서 CMP의 파라메터가 3이다. 만약 시작 위치 기준 오프셋을 쓴다면 6이 될 것이다. 그러나 현재 위치 기준 오프셋을 쓰는것이 구현이 더 편하다.

실제 리얼 머신 어셈블리어에서도 현재 프로그램 카운터 기준으로 오프셋을 상대 주소로 사용하는 어드레싱 모드가 있다. Program Counter based relative addressing이라는 용어를 찾아보면 된다.