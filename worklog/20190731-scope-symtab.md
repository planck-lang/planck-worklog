# 20190731

## 변수 스코프와 심볼 테이블

거의 모든 프로그래밍 언어는 로컬 변수에 스코프를 제한한다. 블록 안에서 선언한 로컬 변수는 블록이 끝나면 더이상 유효하지 않다. 프로그래밍 언어를 공부할 때 누구나 기본적으로 알아야 하는 내용이므로 더이상 자세한 설명은 하지 않겠다.

인터프리터 내부에서 어떤 식으로든 변수 스코프를 관리한다. 그래서 스코프 밖에서 변수를 호출했을 때 적절한 에러 처리를 하면 된다. 스코프에 대한 정보는 무엇이 좋을까? 이를 정하려면 스코프를 어떻게 결정하는지 생각해야 한다. 변수 스코프를 블록으로 한정하는 것이 일반적이다. 

블록은 시작과 끝이 명확하고 중첩 가능하기 때문에 상위 블록에서 선언한 변수의 스코프는 하위 블록에서도 유효하다. 따라서 변수의 스코프를 관리하는데 필요한 정보는 블록의 깊이 정보면 충분하다. 블록의 깊이 정보는 블록을 시작할 때 늘리고 블록을 나갈 때 줄인다. 단순히 카운터로 구현 가능하다.

```
// block_count = 0
if a == 3 {
// block_count = 1
  if b == 4 {
  // block_count = 2
    if c == 5 {
	// block_count =3
	}
 // block_count = 2
   }
// block_count = 1
}
// block_count = 0
```

block_count가 0인 블록에서 만든 변수는 block_count가 1, 2, 3인 블록에서도 모두 유효하다. 그러나 block_count가 3인 블록에서 만든 변수는 block_count가 2인 블록으로 나오면 더이상 유효하지 않다.

직관적으로 먼저 떠 오르는 구현 방법은 심볼 테이블에 변수가 선언된 블록 깊이 값을 적어 놓는 것이다. 그래서 블록 카운트가 줄어들면(블록을 나오면) 현재 블록 카운트보다 큰 값이 적힌 심볼은 심볼 테이블에서 지운다. 이 방법은 이해하기 쉽다는 장점이 있다. 다만 블록을 나올 때 마다 전체 심볼 테이블을 모두 검색해서 심볼을 지워야 하는 문제가 있다. 실제로는 전체 심볼 테이블을 검색하지 않아도 된다. 방금 나온 블록에서 만든 변수의 심볼 정보는 가장 최근에서 생성한 순서대로 적히기 때문이다. 그래서 심볼 테이블을 역순으로 검색하면서 블록 깊이가 현재 블록 깊이랑 같아 질 때까지만 검색하면 된다.

블록에서 만든 변수의 심볼을 심볼 테이블에 적었다가 지우는 과정을 잘 생각해 본다. 이 과정은 스택의 동작 과정과 같다. 그래서 심볼 테이블 자체를 스택으로 구현 하는 방법도 생각해 볼만 하다. 기본 원리는 같다. 다만 심볼 테이블에 블록 깊이 정보를 가지지 않는다. 대신 심볼 테이블 자체를 한 덩어리로 보고 이것을 스택에 쌓는다. 블록에 새로 진입하면 새 심볼 테이블을 만들어서 블록에서 만든 변수 정보를 적는다. 블록을 나가면 스택에서 pop해서 해당 심볼 테이블 자체를 지워버린다.

한 블록에서 변수를 몇 만개 만들지 않는한 두 방법 간에 성능 차이는 별로 없다. 어떤 방법이 보다 구현하기 깔끔하냐의 차이정도만 있다. 나는 고민하다가 두 번째 방법으로 구현했다.