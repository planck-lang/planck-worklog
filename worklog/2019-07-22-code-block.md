# 20190722

## 코드 블록 시작과 끝

인터프리터는 무조건 코드를 한 줄씩 읽어서 해석한다. 그렇다면 코드 블록을 처리할 때는 어떻게 해야 할까? 코드 블록은 한 줄이 아니다. 

```
if sq < sq.max_num {
	num_t sq = y * y;
	sq <<= 2;
}
```

아무 의미없는 위 코드를 보자. if 구문 안에 코드 두 줄이 있다. "구문 안에"라는 표현 자체가 코드 블록을 말한다. 인터프리터는 코드 블록 내부에 코드를 한 줄씩 해석한다. 이 점은 변함없다. 그러나 코드 블록은 특정 문법에 종속된다. 예를 들어 위 코드는 if 문법에 종속된다. 따라서 위 코드의 블록은 if 구문의 조건이 참일 때만 실행된다. 거짓이라면 인터프리터는 아예 해석을 건너 뛴다. 이 시점에서 인터프리터의 컴파일과 실행을 분리해야 한다.

나는 해석이라는 용어로 인터프리터가 하는일을 한 번에 말했다. 그러나 엄밀히 두 단계로 나눠서 인터프리터의 해석이라는 동작을 설명해야 한다. 번역(컴파일)과 실행이다. 인터프리터의 구현에 따라 컴파일이 없는 인터프리터도 가능하다. 플랑크는 컴파일과 실행을 분리했다. 플랑크는 소스 코드를 읽으면 먼저 컴파일해서 바이트 코드로 만든다. 그리고 플랑크 버추얼 머신이 플랑크 바이트 코드를 읽어서 실행하는 구조다.

코드 블록을 읽으면 일단 컴파일은 순서대로 한다. 코드는 만들어야 하기 때문이다. 하지만 이전처럼 코드를 만들자마자 바로 버추얼 머신으로 코드를 보내지 않는다. 코드는 일단 만들어 놓고 블록이 끝날 때까지 컴파일만 한다. 그리고 블록이 끝나면 버추얼 머신으로 보내지 않은 코드를 한 번에 버추얼 머신으로 보내서 실행한다.

만약, 중첩된 코드 블록이라면 가장 바깥 코드 블록이 끝날 때까지 실행하지 않는다. 코드 블록 안에 코드 블록이 또 있으면 코드 블록 깊이를 늘린다. 코드 블록이 끝나면 코드 블록 깊이를 줄인다. 그래서 코드 블록 깊이가 0이 될 때 실행하는 것이다.

```
if 코드 블록 시작 == true {
	코드 블록 깊이++;
} else {
	코드 블록 깊이--;
}

if 코드 블록 깊이 == 0 {
	버추얼 머신 실행
}
```

의사 코드로 표현하면 위와 같다. 

내부 동작은 이러하지만, 입력을 끊어 받는것은 안된다. 이유는 flex, bison이 전체 문법 단위로 입력을 받기 때문이다. 내가 lexical analyzer와 syntax parser를 직접 구현했다면 입력에서부터 직관적으로 연결되게 작업했을 것이다. 그러나 나는 문법 처리 관련 기능은 flex와 bison으로 구현했다. 그래서 입력이 flex, bison에 종속된다. bison은 문법 한 단위가 완전히 들어와야 parse tree를 만들 수 있다. bison rule에서 코드 블록은 문법 하나로 정의한다.

```
block : '{' stmt_list '}'
```

위 rule로 코드 블록을 정의했다. 따라서 stmt_list에 해당하는 문법이 statement 여러줄로 입력 가능하고 각각을 따로 따로 컴파일 할 수 있다 하더라도 한 번에 입력 받아야 bison에서 제대로 처리된다. bison이 개별적 stmt가 아니라 stmt_list로 rule을 인식해야 하기 때문이다. 물론 bison rule을 복잡하게 만들어서 입력을 개별적으로 받아도 코드 블록을 원할히 처리할 수 있게 만들 순 있다. 하지만 bison rule 코드 자체의 가독성이 떨어져 이해가 어려운 문제가 생긴다. 나는 내가 할 수 있는한 쉽게 코드를 쓰고 싶어서 차라리 입력에서 꼼수를 쓰기로 결정했다.

방법은 간단하다. 코드 블럭을 연 것을 확인하면 인터프리터로 코드를 보내지 않고 입력단에서 코드를 계속 쌓는다. 코드를 계속 누적하다가 코드 블록이 끝나면, 한 번에 코드 버퍼를 인터프리터로 보낸다. flex와 bison은 입력이 아무리 길어도 정해진 rule 대로 쭉 처리할 것이기 때문에 이후 구현은 바꾸지 않아도 된다.

