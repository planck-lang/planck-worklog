# 20190701
## 바이트 코드에서 테이블 레퍼런스
인터프리터 내부 구현에서 메모리 포인터 레퍼런스는 나중에 바이트 코드 파일을 별도로 생성하는 상황을 고려해야 한다. 어차피 인터프리터도 C로 만든 프로그램이기 때문에 문자열같은 정보는 메모리 어딘가에 할당해서 포인터로 관리해야 한다. 중요한 지점이다. 플랑크 코드를 바이트 코드로 만들고 바이트 코드를 다시 읽었을 때, 인터프리터 내부에 메모리 구조를 텍스트 소스 코드를 읽을 때와 동일하게 문제없이 생성해야한다.

바이트 코드에서는 인터프리터 내부 포인터 주소를 사용하면 안된다. 예를 들어 아래 코드를 생각해보자.

```
char* str = "abc";
printf("%p", str);
```

위 코드 결과는 어느 적당한 메모리 주소값일 것이다. 0x393924라고 가정하자. 그리고 아래 같은 플랑크 인터프리터 동작을 보자.

```
>> "abc" ## "def"
"abcdef"
```

인터프리터 내부에 "abc"와 "def"는 문자열 리터럴로 처리된다. 그래서 문자열 리터럴 테이블에 저장되고 포인터를 가진다. 결국 인터프리터 내부에서 위에 있는 C언어 코드같은 동작을 한다. 그러면 바이트 코드는 두 가지 형태로 만들 수 있다.

```
opcode_push_str 0x393924		// pointer for "abc"
opcode_push_str 0x393934		// pointer for "def"
```

바이트 코드에서 문자열 리터럴 테이블에 저장한 문자열 포인터 값을 직접 핸들링하는 방식이다.

```
opcode_push_str 0x1			// literal table index for "abc"
opcode_push_str 0x2			// literal table index for "def"
```

그리고 문자열 리터럴 테이블의 인덱스를 핸들링하는 방식이다.

문자열 포인터 주소를 직접 핸들링하는 방식은 플랑크 소스 코드를 인터프리터가 읽어서 처리할 때는 문제가 없다. 그러나 바이트 코드를 읽을 때는 문제가 생긴다. 왜냐하면 바이트 코드를 해석하는 시점에서 해당 머신의 0x393924 메모리 주소에 원하는 문자열을 배치해 놔야하기 때문이다. 아니면 바이트 코드를 해석하기 전에 일종의 메모리 리로케이션 개념으로 바이트 코드를 파싱하면서 해당 주소를 재배치해야 한다. 번거로운 일이다.

리터럴 테이블 인덱스를 핸들링하는 방식은 보다 유연하다. 바이트 코드를 읽는 시점에 바이트 코드에서 리터럴 테이블과 심볼 테이블을 읽어 인터프리터 내부에 자료구조를 생성한다. 바이트 코드에서는 내부 자료구조 인덱스를 핸들링하고 테이블 자료구조 인덱스를 기반으로 실제 포인터를 받는다. 그리고 인터프리터 스택에 push할 때는 이 포인터 값을 push한다. 그러면 VM은 소스 코드를 읽을 때나 바이트 코드를 읽을 때나 동일하게 동작한다.

## 생각할 점
바이트 코드를 여러개 읽을 때는 바이트 코드별로 테이블을 관리해야 하는가? 인터프리터에 통합해야 하는가? 인터프리터에 통합해야 한다면 어차피 인덱스 재배치는 필요하다.

